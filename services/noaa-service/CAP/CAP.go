package CAP

import (
	"encoding/xml"
	"errors"
	"strconv"
	"strings"
	"time"
)

/* -------------------------------- XML CAP -------------------------------- */
// ---- Everything in this section was generated by xgen ----
// EventCodeXML ...
type EventCodeXML struct {
	XMLName      xml.Name `xml:"eventCode"`
	CapValueName string   `xml:"valueName"`
	CapValue     string   `xml:"value"`
}

// ParameterXML ...
type ParameterXML struct {
	XMLName      xml.Name `xml:"parameter"`
	CapValueName string   `xml:"valueName"`
	CapValue     string   `xml:"value"`
}

// ResourceXML ...
type ResourceXML struct {
	XMLName      xml.Name `xml:"resource"`
	ResourceDesc string   `xml:"resourceDesc"`
	MimeType     string   `xml:"mimeType"`
	Size         int      `xml:"size"`
	Uri          string   `xml:"uri"`
	DerefUri     string   `xml:"derefUri"`
	Digest       string   `xml:"digest"`
}

// GeocodeXML ...
type GeocodeXML struct {
	XMLName      xml.Name `xml:"geocode"`
	CapValueName string   `xml:"valueName"`
	CapValue     string   `xml:"value"`
}

// AreaXML ...
type AreaXML struct {
	XMLName  xml.Name      `xml:"area"`
	AreaDesc string        `xml:"areaDesc"`
	Polygon  []string      `xml:"polygon"`
	Circle   []string      `xml:"circle"`
	Geocode  []*GeocodeXML `xml:"geocode"`
	Altitude float64       `xml:"altitude"`
	Ceiling  float64       `xml:"ceiling"`
}

// InfoXML ...
type InfoXML struct {
	XMLName      xml.Name        `xml:"info"`
	Language     string          `xml:"language"`
	Category     []string        `xml:"category"`
	Event        string          `xml:"event"`
	ResponseType []string        `xml:"responseType"`
	Urgency      string          `xml:"urgency"`
	Severity     string          `xml:"severity"`
	Certainty    string          `xml:"certainty"`
	Audience     string          `xml:"audience"`
	EventCode    []*EventCodeXML `xml:"eventCode"`
	Effective    string          `xml:"effective"`
	Onset        string          `xml:"onset"`
	Expires      string          `xml:"expires"`
	SenderName   string          `xml:"senderName"`
	Headline     string          `xml:"headline"`
	Description  string          `xml:"description"`
	Instruction  string          `xml:"instruction"`
	Web          string          `xml:"web"`
	Contact      string          `xml:"contact"`
	Parameter    []*ParameterXML `xml:"parameter"`
	Resource     []*ResourceXML  `xml:"resource"`
	Area         []*AreaXML      `xml:"area"`
}

// AlertXML ...
type AlertXML struct {
	XMLName     xml.Name   `xml:"alert"`
	Identifier  string     `xml:"identifier"`
	Sender      string     `xml:"sender"`
	Sent        string     `xml:"sent"`
	Status      string     `xml:"status"`
	MsgType     string     `xml:"msgType"`
	Source      string     `xml:"source"`
	Scope       string     `xml:"scope"`
	Restriction string     `xml:"restriction"`
	Addresses   string     `xml:"addresses"`
	Code        []string   `xml:"code"`
	Note        string     `xml:"note"`
	References  string     `xml:"references"`
	Incidents   string     `xml:"incidents"`
	Info        []*InfoXML `xml:"info"`
}

// ExpiresXML ...
type ExpiresXML string

// ValueNameXML ...
type ValueNameXML string

// ValueXML ...
type ValueXML string

// --------------------------------------------------------------------------
/* -------------------------------- JSON CAP -------------------------------- */

type Alert struct {
	Identifier  string      `json:"identifier"`
	Sender      string      `json:"sender"`
	Sent        time.Time   `json:"sent"`
	Status      string      `json:"status"`
	MsgType     string      `json:"msgType"`
	Source      string      `json:"source"`
	Scope       string      `json:"scope"`
	Restriction string      `json:"restriction,omitempty"`
	Addresses   string      `json:"addresses,omitempty"`
	Code        []string    `json:"code"`
	Note        string      `json:"note,omitempty"`
	References  []Reference `json:"references,omitempty"`
	Incidents   string      `json:"incidents,omitempty"`
	Info        Info        `json:"info"`
	InfoSpanish *Info       `json:"infoSpanish,omitempty"`
}

type Reference struct {
	Sender     string    `json:"sender"`
	Identifier string    `json:"identifier"`
	Sent       time.Time `json:"sent"`
}

type Info struct {
	Language     string      `json:"language"`
	Categories   Categories  `json:"categories"`
	Event        string      `json:"event"`
	ResponseType string      `json:"responseType"`
	Urgency      string      `json:"urgency"`
	Severity     string      `json:"severity"`
	Certainty    string      `json:"certainty"`
	Audience     string      `json:"audience,omitempty"`
	EventCode    EventCode   `json:"eventCode"`
	Effective    time.Time   `json:"effective"`
	Onset        time.Time   `json:"onset"`
	Expires      time.Time   `json:"expires"`
	SenderName   string      `json:"senderName"`
	Headline     string      `json:"headline"`
	Description  string      `json:"description"`
	Instruction  string      `json:"instruction"`
	Web          string      `json:"web"`
	Contact      string      `json:"contact"`
	Parameters   *Parameters `json:"parameters,omitempty"`
	Resource     []Resource  `json:"resource,omitempty"`
	Area         Area        `json:"area"`
}

type Categories struct {
	Geo       bool `json:"Geo"`
	Met       bool `json:"Met"`
	Safety    bool `json:"Safety"`
	Rescue    bool `json:"Rescue"`
	Fire      bool `json:"Fire"`
	Health    bool `json:"Health"`
	Env       bool `json:"Env"`
	Transport bool `json:"Transport"`
	Infra     bool `json:"Infra"`
	CBRNE     bool `json:"CBRNE"`
	Other     bool `json:"Other"`
}

type EventCode struct {
	SAME string `json:"SAME"`
	NWS  string `json:"NWS"`
}

type Parameters struct {
	AWIPSidentifier          string                  `json:"AWIPSidentifier,omitempty"`
	WMOidentifier            string                  `json:"WMOidentifier,omitempty"`
	NWSheadline              string                  `json:"NWSheadline,omitempty"`
	EventMotionDescription   *EventMotionDescription `json:"eventMotionDescription,omitempty"`
	WindThreat               string                  `json:"windThreat,omitempty"`
	MaxWindGust              float64                 `json:"maxWindGust,omitempty"`
	HailThreat               string                  `json:"hailThreat,omitempty"`
	MaxHailSize              float64                 `json:"maxHailSize,omitempty"`
	ThunderstormDamageThreat string                  `json:"thunderstormDamageThreat,omitempty"`
	TornadoDetection         string                  `json:"tornadoDetection,omitempty"`
	TornadoDamageThreat      string                  `json:"tornadoDamageThreat,omitempty"`
	FlashFloodDetection      string                  `json:"flashFloodDetection,omitempty"`
	FlashFloodDamageThreat   string                  `json:"flashFloodDamageThreat,omitempty"`
	SnowSquallDetection      string                  `json:"snowSquallDetection,omitempty"`
	SnowSquallImpact         string                  `json:"snowSquallImpact,omitempty"`
	WaterspoutDetection      string                  `json:"waterspoutDetection,omitempty"`
	BlockChannels            BlockChannels           `json:"blockChannels,omitempty"`
	EASORG                   string                  `json:"EAS-ORG,omitempty"`
	VTEC                     string                  `json:"VTEC,omitempty"`
	EventEndingTime          time.Time               `json:"eventEndingTime,omitempty"`
	WEAHandlingCode          string                  `json:"WEAHandling,omitempty"`
	CMAMtext                 string                  `json:"CMAMtext,omitempty"`
	CMAMlongtext             string                  `json:"CMAMlongtext,omitempty"`
	ExpiredReferences        []Reference             `json:"expiredReferences,omitempty"`
}

type EventMotionDescription struct {
	Timestamp time.Time    `json:"timestamp"`
	Direction string       `json:"direction"` // Expected to be a three-digit string (non-`000`)
	Speed     string       `json:"speed"`     // A one- or two-digit value (without leading zero unless `0`)
	Location  []Coordinate `json:"location"`  // One or more coordinate pairs
}

type Coordinate struct {
	Lat float64 `json:"lat"`
	Lon float64 `json:"lon"`
}

type BlockChannels struct {
	CMAS   bool `json:"CMAS"`
	EAS    bool `json:"EAS"`
	NWEM   bool `json:"NWEM"`
	Public bool `json:"Public"`
}

type Resource struct {
	ResourceDesc string `json:"resourceDesc"`
	MimeType     string `json:"mimeType"`
	Size         int    `json:"size"`
	URI          string `json:"uri"`
	DerefURI     string `json:"derefUri"`
	Digest       string `json:"digest"`
}

type Area struct {
	Description string          `json:"description"`
	Polygon     *GeoJSONPolygon `json:"polygon,omitempty"`
	Geocodes    Geocodes        `json:"geocodes"`
}

type GeoJSONPolygon struct {
	Type        string        `json:"type"` // should always be `Polygon`
	Coordinates [][][]float64 `json:"coordinates"`
}

type Geocodes struct {
	UGC  []string `json:"UGC"`
	SAME []string `json:"SAME"`
}

func ConvertXMLToJsonStruct(old *AlertXML) (*Alert, error) {
	var err error
	newAlert := &Alert{
		Identifier:  old.Identifier,
		Sender:      old.Sender,
		Status:      old.Status,
		MsgType:     old.MsgType,
		Source:      old.Source,
		Scope:       old.Scope,
		Restriction: old.Restriction,
		Addresses:   old.Addresses,
		Code:        old.Code,
		Note:        old.Note,
		Incidents:   old.Incidents,
	}

	newAlert.Sent, err = time.Parse(time.RFC3339, old.Sent)
	if err != nil {
		return nil, err
	}

	newAlert.References = convertReferences(old.References)

	if len(old.Info) > 0 {
		for _, oinfo := range old.Info {
			if oinfo == nil {
				continue
			}
			ni, err := convertInfo(oinfo)
			if err != nil {
				return nil, err
			}
			if oinfo.Language == "es-US" {
				newAlert.InfoSpanish = &ni
			} else {
				newAlert.Info = ni
			}
		}
	} else {
		ni, err := convertInfo(old.Info[0])
		if err != nil {
			return nil, err
		}
		newAlert.Info = ni
		newAlert.InfoSpanish = nil
	}

	return newAlert, nil
}

func convertReferences(refs string) []Reference {
	var out []Reference
	parts := strings.Fields(refs)
	for _, ref := range parts {
		tokens := strings.Split(ref, ",")
		if len(tokens) != 3 {
			continue
		}
		sent, err := time.Parse(time.RFC3339, tokens[2])
		if err != nil {
			continue
		}
		out = append(out, Reference{
			Sender:     tokens[0],
			Identifier: tokens[1],
			Sent:       sent,
		})
	}
	return out
}

func convertInfo(old *InfoXML) (Info, error) {
	var err error
	var ni Info
	ni.Language = old.Language
	ni.Categories = convertCategories(old.Category)
	ni.Event = old.Event
	if len(old.ResponseType) > 0 {
		ni.ResponseType = old.ResponseType[0]
	}
	ni.Urgency = old.Urgency
	ni.Severity = old.Severity
	ni.Certainty = old.Certainty
	ni.Audience = old.Audience

	ni.EventCode = convertEventCode(old.EventCode)

	ni.Effective, err = time.Parse(time.RFC3339, old.Effective)
	if err != nil {
		return ni, err
	}
	ni.Onset, err = time.Parse(time.RFC3339, old.Onset)
	if err != nil {
		return ni, err
	}
	ni.Expires, err = time.Parse(time.RFC3339, old.Expires)
	if err != nil {
		return ni, err
	}

	ni.SenderName = old.SenderName
	ni.Headline = old.Headline
	ni.Description = old.Description
	ni.Instruction = old.Instruction
	ni.Web = old.Web
	ni.Contact = old.Contact

	ni.Parameters = convertParameters(old.Parameter)
	ni.Resource = convertResources(old.Resource)

	if len(old.Area) > 0 && old.Area[0] != nil {
		area, err := convertArea(old.Area[0])
		if err != nil {
			return ni, err
		}
		ni.Area = area
	} else {
		return ni, errors.New("no area information found")
	}

	return ni, nil
}

func convertCategories(cats []string) Categories {
	var c Categories
	for _, cat := range cats {
		switch cat {
		case "Geo":
			c.Geo = true
		case "Met":
			c.Met = true
		case "Safety":
			c.Safety = true
		case "Rescue":
			c.Rescue = true
		case "Fire":
			c.Fire = true
		case "Health":
			c.Health = true
		case "Env":
			c.Env = true
		case "Transport":
			c.Transport = true
		case "Infra":
			c.Infra = true
		case "CBRNE":
			c.CBRNE = true
		case "Other":
			c.Other = true
		}
	}
	return c
}

func convertEventCode(codes []*EventCodeXML) EventCode {
	var ec EventCode
	for _, code := range codes {
		switch code.CapValueName {
		case "SAME":
			ec.SAME = code.CapValue
		case "NationalWeatherService":
			ec.NWS = code.CapValue
		}
	}
	return ec
}

func convertParameters(oldParams []*ParameterXML) *Parameters {
	if len(oldParams) == 0 {
		return nil
	}
	newParams := &Parameters{}
	for _, param := range oldParams {
		switch param.CapValueName {
		case "AWIPSidentifier":
			newParams.AWIPSidentifier = param.CapValue
		case "WMOidentifier":
			newParams.WMOidentifier = param.CapValue
		case "NWSheadline":
			newParams.NWSheadline = param.CapValue
		case "eventMotionDescription":
			newParams.EventMotionDescription = convertEventMotionDescriptionFromString(param.CapValue)
		case "windThreat":
			newParams.WindThreat = param.CapValue
		case "maxWindGust":
			if val, err := strconv.ParseFloat(param.CapValue, 64); err == nil {
				newParams.MaxWindGust = val
			}
		case "hailThreat":
			newParams.HailThreat = param.CapValue
		case "maxHailSize":
			if val, err := strconv.ParseFloat(param.CapValue, 64); err == nil {
				newParams.MaxHailSize = val
			}
		case "thunderstormDamageThreat":
			newParams.ThunderstormDamageThreat = param.CapValue
		case "tornadoDetection":
			newParams.TornadoDetection = param.CapValue
		case "tornadoDamageThreat":
			newParams.TornadoDamageThreat = param.CapValue
		case "flashFloodDetection":
			newParams.FlashFloodDetection = param.CapValue
		case "flashFloodDamageThreat":
			newParams.FlashFloodDamageThreat = param.CapValue
		case "snowSquallDetection":
			newParams.SnowSquallDetection = param.CapValue
		case "snowSquallImpact":
			newParams.SnowSquallImpact = param.CapValue
		case "waterspoutDetection":
			newParams.WaterspoutDetection = param.CapValue
		case "BLOCKCHANNEL":
			newParams.BlockChannels = convertBlockChannels(param.CapValue)
		case "EAS-ORG":
			newParams.EASORG = param.CapValue
		case "VTEC":
			newParams.VTEC = param.CapValue
		case "eventEndingTime":
			val, err := time.Parse(time.RFC3339, param.CapValue)
			if err == nil {
				newParams.EventEndingTime = val
			}
		case "WEAHandling":
			newParams.WEAHandlingCode = param.CapValue
		case "CMAMtext":
			newParams.CMAMtext = param.CapValue
		case "CMAMlongtext":
			newParams.CMAMlongtext = param.CapValue
		case "expiredReferences":
			newParams.ExpiredReferences = convertReferences(param.CapValue)
		}
	}
	return newParams
}
func convertResources(oldRes []*ResourceXML) []Resource {
	var res []Resource
	for _, o := range oldRes {
		if o == nil {
			continue
		}
		res = append(res, Resource{
			ResourceDesc: o.ResourceDesc,
			MimeType:     o.MimeType,
			Size:         o.Size,
			URI:          o.Uri,
			DerefURI:     o.DerefUri,
			Digest:       o.Digest,
		})
	}
	return res
}

func convertEventMotionDescriptionFromString(s string) *EventMotionDescription {
	parts := strings.Split(s, "|")
	if len(parts) < 4 {
		return nil
	}
	ts, err := time.Parse(time.RFC3339, parts[0])
	if err != nil {
		return nil
	}
	direction := parts[1]
	speed := parts[2]
	locationStr := parts[3]
	locPairs := strings.Split(locationStr, ";")
	var locations []Coordinate
	for _, pair := range locPairs {
		coords := strings.Split(pair, ",")
		if len(coords) != 2 {
			continue
		}
		lat, err1 := strconv.ParseFloat(coords[0], 64)
		lon, err2 := strconv.ParseFloat(coords[1], 64)
		if err1 != nil || err2 != nil {
			continue
		}
		locations = append(locations, Coordinate{
			Lat: lat,
			Lon: lon,
		})
	}
	return &EventMotionDescription{
		Timestamp: ts,
		Direction: direction,
		Speed:     speed,
		Location:  locations,
	}
}

func convertBlockChannels(s string) BlockChannels {
	bc := BlockChannels{}
	channels := strings.Split(s, ",")
	for _, channel := range channels {
		channel = strings.TrimSpace(channel)
		switch channel {
		case "CMAS":
			bc.CMAS = true
		case "EAS":
			bc.EAS = true
		case "NWEM":
			bc.NWEM = true
		case "Public":
			bc.Public = true
		}
	}
	return bc
}

// convertArea converts an OldArea into a new Area.
func convertArea(old *AreaXML) (Area, error) {
	var a Area
	a.Description = old.AreaDesc
	a.Polygon = convertPolygon(old.Polygon)
	a.Geocodes = convertGeocodes(old.Geocode)
	return a, nil
}

// convertPolygon converts a slice of polygon strings into a GeoPolygon.
// This example assumes each polygon string is a series of "lat,lon" pairs separated by whitespace.
func convertPolygon(polys []string) *GeoJSONPolygon {
	if len(polys) == 0 {
		return nil
	}
	// For simplicity, use the first polygon string.
	points := strings.Fields(polys[0])
	var coords [][]float64
	for _, pt := range points {
		parts := strings.Split(pt, ",")
		if len(parts) != 2 {
			continue
		}
		lat, err1 := strconv.ParseFloat(parts[0], 64)
		lon, err2 := strconv.ParseFloat(parts[1], 64)
		if err1 != nil || err2 != nil {
			continue
		}
		// GeoJSON uses [lon, lat]
		coords = append(coords, []float64{lon, lat})
	}
	// Ensure the polygon is closed.
	if len(coords) > 0 {
		first := coords[0]
		last := coords[len(coords)-1]
		if first[0] != last[0] || first[1] != last[1] {
			coords = append(coords, first)
		}
	}
	return &GeoJSONPolygon{
		Type:        "Polygon",
		Coordinates: [][][]float64{coords},
	}
}

// convertGeocodes converts a slice of OldGeocode into a Geocodes struct.
func convertGeocodes(oldCodes []*GeocodeXML) Geocodes {
	var gc Geocodes
	for _, code := range oldCodes {
		switch code.CapValueName {
		case "UGC":
			gc.UGC = append(gc.UGC, code.CapValue)
		case "SAME":
			gc.SAME = append(gc.SAME, code.CapValue)
		}
	}
	return gc
}
