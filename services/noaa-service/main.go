package main

import (
	"crypto/tls"
	"encoding/xml"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"
	"time"

	ampq "github.com/rabbitmq/amqp091-go"
	"github.com/xmppo/go-xmpp"
)

// ---- Everything in this section was generated by xgen ----
// EventCode ...
type EventCode struct {
	XMLName      xml.Name `xml:"eventCode"`
	CapValueName string   `xml:"valueName"`
	CapValue     string   `xml:"value"`
}

// Parameter ...
type Parameter struct {
	XMLName      xml.Name `xml:"parameter"`
	CapValueName string   `xml:"valueName"`
	CapValue     string   `xml:"value"`
}

// Resource ...
type Resource struct {
	XMLName      xml.Name `xml:"resource"`
	ResourceDesc string   `xml:"resourceDesc"`
	MimeType     string   `xml:"mimeType"`
	Size         int      `xml:"size"`
	Uri          string   `xml:"uri"`
	DerefUri     string   `xml:"derefUri"`
	Digest       string   `xml:"digest"`
}

// Geocode ...
type Geocode struct {
	XMLName      xml.Name `xml:"geocode"`
	CapValueName string   `xml:"valueName"`
	CapValue     string   `xml:"value"`
}

// Area ...
type Area struct {
	XMLName  xml.Name   `xml:"area"`
	AreaDesc string     `xml:"areaDesc"`
	Polygon  []string   `xml:"polygon"`
	Circle   []string   `xml:"circle"`
	Geocode  []*Geocode `xml:"geocode"`
	Altitude float64    `xml:"altitude"`
	Ceiling  float64    `xml:"ceiling"`
}

// Info ...
type Info struct {
	XMLName      xml.Name     `xml:"info"`
	Language     string       `xml:"language"`
	Category     []string     `xml:"category"`
	Event        string       `xml:"event"`
	ResponseType []string     `xml:"responseType"`
	Urgency      string       `xml:"urgency"`
	Severity     string       `xml:"severity"`
	Certainty    string       `xml:"certainty"`
	Audience     string       `xml:"audience"`
	EventCode    []*EventCode `xml:"eventCode"`
	Effective    string       `xml:"effective"`
	Onset        string       `xml:"onset"`
	Expires      string       `xml:"expires"`
	SenderName   string       `xml:"senderName"`
	Headline     string       `xml:"headline"`
	Description  string       `xml:"description"`
	Instruction  string       `xml:"instruction"`
	Web          string       `xml:"web"`
	Contact      string       `xml:"contact"`
	Parameter    []*Parameter `xml:"parameter"`
	Resource     []*Resource  `xml:"resource"`
	Area         []*Area      `xml:"area"`
}

// Alert ...
type Alert struct {
	XMLName     xml.Name `xml:"alert"`
	Identifier  string   `xml:"identifier"`
	Sender      string   `xml:"sender"`
	Sent        string   `xml:"sent"`
	Status      string   `xml:"status"`
	MsgType     string   `xml:"msgType"`
	Source      string   `xml:"source"`
	Scope       string   `xml:"scope"`
	Restriction string   `xml:"restriction"`
	Addresses   string   `xml:"addresses"`
	Code        []string `xml:"code"`
	Note        string   `xml:"note"`
	References  string   `xml:"references"`
	Incidents   string   `xml:"incidents"`
	Info        []*Info  `xml:"info"`
}

// Expires ...
type Expires string

// ValueName ...
type ValueName string

// Value ...
type Value string

// ---------------------------------------------------------

type VTEC struct {
	// Raw VTEC string
	StringValue string
	// Identifies the following product and VTEC code string types, most of the time O, E, and T
	FixedIdentifier string
	/*
		NEW - New, CON - Continued, EXA - Extended in Area, EXT - Extended in Time, EXB - Extended in Area and Changed in Time
		UPG - Upgraded, CAN - Cancelled, EXP - Expired, ROU - Routine, COR - Correction
	*/
	Action string
	// The 4 letter office identifier
	OfficeID string
	// A 2 letter code that identifies the hazard type, will need to be converted to appropriate NWS code.
	Phenomenon string
	// The significance of the hazard, W - Warning, A - Watch, Y - Advisory
	Significance string
	// The ETN is a four-digit number assigned to keep track of how an event (as defined in Section 1.4) is addressed by various VTEC actions and/or products issued over the lifetime of the event.
	ETN string
	// The start time of the event
	EventBeginTime string
	// The end time of the event
	EventEndTime string
}

// Message queue connection
var ch *ampq.Channel
var trackingQueue ampq.Queue

func connectToMQ() {
	conn, err := ampq.Dial(os.Getenv("RABBITMQ_URL"))
	if err != nil {
		log.Fatalf("Failed to connect to the message queue")
		return
	}
	defer conn.Close()

	ch, err = conn.Channel()
	if err != nil {
		log.Fatalf("Failed to open a channel")
	}
	defer ch.Close()

	trackingQueue, err = ch.QueueDeclare("tracking", true, false, false, false, nil)
	if err != nil {
		log.Fatalf("Failed to declare the tracking queue")
	}

}

func main() {
	log.Println("SIREN - Service for Instant Relay of Emergency Notifications")

	log.Println("Starting connection to message queue...")
	connectToMQ()

	log.Println("Starting connection to NWWS ingress server...")
	// Create an XMPP client
	options := xmpp.Options{
		Host:          "nwws-oi.weather.gov:5222",
		User:          os.Getenv("NWWS_USER"),
		Password:      os.Getenv("NWWS_PASSWORD"),
		Resource:      "nwws",
		NoTLS:         true,
		StartTLS:      true,
		Debug:         false,
		Session:       true,
		Status:        "chat",
		StatusMessage: "",
		TLSConfig: &tls.Config{
			ServerName: "nwws-oi.weather.gov",
		},
	}

	client, err := options.NewClient()
	if err != nil {
		log.Fatalf("Error creating XMPP client: %v", err)
	}
	fmt.Println("Logged into client")
	defer client.Close()

	_, err = client.JoinMUC("NWWS@conference.nwws-oi.weather.gov", os.Getenv("NWWS_NICKNAME"), xmpp.StanzaHistory, 50, nil)
	if err != nil {
		log.Fatalf("Failed to join MUC: %v", err)
	}

	fmt.Println("Joined group chat")

	alerts := make(chan string)
	go handleAlertXML(alerts)

	for {
		stanza, err := client.Recv()
		if err != nil {
			//TODO: Implement reconnection logic
			log.Printf("Receive error: %v\n", err)
			time.Sleep(5 * time.Second)
			continue
		}

		switch v := stanza.(type) {
		case xmpp.Chat:
			if v.Type == "groupchat" {
				for _, child := range v.OtherElem {
					if child.XMLName.Local == "x" {
						awipsID := ""
						for _, attr := range child.Attr {
							if attr.Name.Local == "awipsid" {
								awipsID = attr.Value
								break
							}
						}
						if strings.HasPrefix(awipsID, "CAP") {
							content := child.InnerXML
							re := regexp.MustCompile(`(?s)(?:<!\[CDATA\[.*?)(<alert.*?>.*?</alert>)(?:.*?\]\]>)`)
							matches := re.FindStringSubmatch(content)
							if len(matches) < 2 {
								log.Println("No <alert> element found in content.")
								continue

							}
							alerts <- matches[1]
						}
					}
				}
			}
		case xmpp.Presence:
			continue
		case xmpp.IQ:
			continue
		default:
			continue
		}
	}

}

func extractVTECValue(xmlStr string) (string, error) {
	re := regexp.MustCompile(`<parameter>\s*<valueName>\s*VTEC\s*</valueName>\s*<value>\s*(.*?)\s*</value>\s*</parameter>`)
	matches := re.FindAllStringSubmatch(xmlStr, -1)
	if len(matches) == 0 {
		return "", fmt.Errorf("no VTEC values found")
	}

	for _, match := range matches {
		if len(match) > 1 {
			value, err := parseVTECValue(match[1])
			if err != nil {
				return "", err
			}

			if value.Action == "NEW" {
				return value.StringValue, nil
			}
		}
	}
	return "", fmt.Errorf("no VTEC values found")
}

func parseVTECValue(vtecValue string) (*VTEC, error) {
	values := strings.Split(strings.Trim(vtecValue, "/"), ".")

	if len(values) != 7 {
		return nil, fmt.Errorf("VTEC value not in correct format")
	}

	return &VTEC{
		StringValue:     vtecValue,
		FixedIdentifier: values[0],
		Action:          values[1],
		OfficeID:        values[2],
		Phenomenon:      values[3],
		Significance:    values[4],
		ETN:             values[5],
		EventBeginTime:  strings.Split(values[6], "-")[0],
		EventEndTime:    strings.Split(values[6], "-")[1],
	}, nil
}

func handleAlertXML(alerts <-chan string) {
	for alertXML := range alerts {
		// Extract the VTEC value from the alert XML
		vtecValue, err := extractVTECValue(alertXML)
		if err != nil {
			log.Println("No valid VTEC found. Skipping alert.")
			continue
		}

		// Parse the VTEC value
		vtec, err := parseVTECValue(vtecValue)
		if err != nil {
			log.Println("Error parsing VTEC value. Skipping alert.")
			continue
		}

		//Create a mostly unique event ID
		eventId := fmt.Sprintf("%s-%s%s-%s", vtec.OfficeID, vtec.Phenomenon, vtec.Significance, vtec.ETN)

		log.Printf("Event ID: %s | Action: %s\n", eventId, vtec.Action)

	}
}
