package main

import (
	"crypto/tls"
	"encoding/xml"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/joho/godotenv"
	ampq "github.com/rabbitmq/amqp091-go"
	"github.com/xmppo/go-xmpp"
)

// ---- Everything in this section was generated by xgen ----
// EventCode ...
type EventCode struct {
	XMLName      xml.Name `xml:"eventCode"`
	CapValueName string   `xml:"valueName"`
	CapValue     string   `xml:"value"`
}

// Parameter ...
type Parameter struct {
	XMLName      xml.Name `xml:"parameter"`
	CapValueName string   `xml:"valueName"`
	CapValue     string   `xml:"value"`
}

// Resource ...
type Resource struct {
	XMLName      xml.Name `xml:"resource"`
	ResourceDesc string   `xml:"resourceDesc"`
	MimeType     string   `xml:"mimeType"`
	Size         int      `xml:"size"`
	Uri          string   `xml:"uri"`
	DerefUri     string   `xml:"derefUri"`
	Digest       string   `xml:"digest"`
}

// Geocode ...
type Geocode struct {
	XMLName      xml.Name `xml:"geocode"`
	CapValueName string   `xml:"valueName"`
	CapValue     string   `xml:"value"`
}

// Area ...
type Area struct {
	XMLName  xml.Name   `xml:"area"`
	AreaDesc string     `xml:"areaDesc"`
	Polygon  []string   `xml:"polygon"`
	Circle   []string   `xml:"circle"`
	Geocode  []*Geocode `xml:"geocode"`
	Altitude float64    `xml:"altitude"`
	Ceiling  float64    `xml:"ceiling"`
}

// Info ...
type Info struct {
	XMLName      xml.Name     `xml:"info"`
	Language     string       `xml:"language"`
	Category     []string     `xml:"category"`
	Event        string       `xml:"event"`
	ResponseType []string     `xml:"responseType"`
	Urgency      string       `xml:"urgency"`
	Severity     string       `xml:"severity"`
	Certainty    string       `xml:"certainty"`
	Audience     string       `xml:"audience"`
	EventCode    []*EventCode `xml:"eventCode"`
	Effective    string       `xml:"effective"`
	Onset        string       `xml:"onset"`
	Expires      string       `xml:"expires"`
	SenderName   string       `xml:"senderName"`
	Headline     string       `xml:"headline"`
	Description  string       `xml:"description"`
	Instruction  string       `xml:"instruction"`
	Web          string       `xml:"web"`
	Contact      string       `xml:"contact"`
	Parameter    []*Parameter `xml:"parameter"`
	Resource     []*Resource  `xml:"resource"`
	Area         []*Area      `xml:"area"`
}

// Alert ...
type Alert struct {
	XMLName     xml.Name `xml:"alert"`
	Identifier  string   `xml:"identifier"`
	Sender      string   `xml:"sender"`
	Sent        string   `xml:"sent"`
	Status      string   `xml:"status"`
	MsgType     string   `xml:"msgType"`
	Source      string   `xml:"source"`
	Scope       string   `xml:"scope"`
	Restriction string   `xml:"restriction"`
	Addresses   string   `xml:"addresses"`
	Code        []string `xml:"code"`
	Note        string   `xml:"note"`
	References  string   `xml:"references"`
	Incidents   string   `xml:"incidents"`
	Info        []*Info  `xml:"info"`
}

// Expires ...
type Expires string

// ValueName ...
type ValueName string

// Value ...
type Value string

// ---------------------------------------------------------
// Message queue connection
var ch *ampq.Channel
var trackingQueue ampq.Queue

func connectToMQ() {
	conn, err := ampq.Dial(os.Getenv("RABBITMQ_URL"))
	if err != nil {
		log.Fatalf("Failed to connect to the message queue")
		return
	}
	defer conn.Close()

	ch, err = conn.Channel()
	if err != nil {
		log.Fatalf("Failed to open a channel")
	}
	defer ch.Close()

	trackingQueue, err = ch.QueueDeclare("tracking", true, false, false, false, nil)
	if err != nil {
		log.Fatalf("Failed to declare the tracking queue")
	}

}

func main() {
	log.Println("SIREN - Service for Instant Relay of Emergency Notifications")

	log.Panicln("Loading environment variables...")
	err := godotenv.Load()
	if err != nil {
		log.Fatalf("Error loading .env file: %v", err)
	}

	log.Println("Starting connection to message queue...")
	connectToMQ()

	log.Println("Starting connection to NWWS ingress server...")
	options := xmpp.Options{
		Host:          "nwws-oi.weather.gov:5222",
		User:          os.Getenv("NWWS_USER"),
		Password:      os.Getenv("NWWS_PASSWORD"),
		Resource:      "nwws",
		NoTLS:         true,
		StartTLS:      true,
		Debug:         false,
		Session:       true,
		Status:        "chat",
		StatusMessage: "",
		TLSConfig: &tls.Config{
			ServerName: "nwws-oi.weather.gov",
		},
	}

	client, err := options.NewClient()
	if err != nil {
		log.Fatalf("Error creating XMPP client: %v", err)
	}
	fmt.Println("Logged into client")
	defer client.Close()

	_, err = client.JoinMUC("NWWS@conference.nwws-oi.weather.gov", os.Getenv("NWWS_NICKNAME"), xmpp.StanzaHistory, 50, nil)
	if err != nil {
		log.Fatalf("Failed to join MUC: %v", err)
	}

	fmt.Println("Joined group chat")

	alerts := make(chan string)
	go handleAlertXML(alerts)

	for {
		stanza, err := client.Recv()
		if err != nil {
			//TODO: Implement reconnection logic
			log.Printf("Receive error: %v\n", err)
			time.Sleep(5 * time.Second)
			continue
		}

		switch v := stanza.(type) {
		case xmpp.Chat:
			if v.Type == "groupchat" {
				for _, child := range v.OtherElem {
					if child.XMLName.Local == "x" {
						awipsID := ""
						for _, attr := range child.Attr {
							if attr.Name.Local == "awipsid" {
								awipsID = attr.Value
								break
							}
						}
						if strings.HasPrefix(awipsID, "CAP") {
							content := child.InnerXML
							re := regexp.MustCompile(`(?s)(?:<!\[CDATA\[.*?)(<alert.*?>.*?</alert>)(?:.*?\]\]>)`)
							matches := re.FindStringSubmatch(content)
							if len(matches) < 2 {
								log.Println("No <alert> element found in content.")
								continue

							}
							alerts <- matches[1]
						}
					}
				}
			}
		case xmpp.Presence:
			continue
		case xmpp.IQ:
			continue
		default:
			continue
		}
	}

}

func handleAlertXML(alerts <-chan string) {
	for alertXML := range alerts {
		var alert Alert
		err := xml.Unmarshal([]byte(alertXML), &alert)
		if err != nil {
			log.Printf("Failed to unmarshal alert: %v\n", err)
			continue
		}

		//Send alert to message queue
		err = ch.Publish("", trackingQueue.Name, false, false, ampq.Publishing{
			ContentType: "text/plain",
			Body:        []byte(alertXML),
		})
		if err != nil {
			log.Printf("Failed to publish alert to message queue: %v\n", err)
		}

	}
}
